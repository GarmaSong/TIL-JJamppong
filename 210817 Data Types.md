> 정보의 전달 보다는 제가 이해한 내용을 까먹지 않기 위해 정리한걸 기록합니다..

### 데이터 타입의 종류

#### 기본형(Primitive type)

- 숫자, 문자열, 불리언, null, undefined, symbol
- 값이 담긴 주소값을 바로 복제
- 얘네들은 불변성을 띰

#### 참조형(Reference type)

- 객체, 배열, 함수, 날짜, 정규식, Map, WeakMap, Set, WeakSet 등
- 근데 위에 있는 애들 사실은 다 넓은 범위의 객체 형태라고 할 수 있음
- 값이 담긴 주소값으로 이루어진 묶음을 가르키는 주소값을 복제함

### 데이터 타입에 관한 배경지식

#### 비트(Bit)

- 0 또는 1로만 표현할 수 있는 메모리 조각
- 각 비트는 고유한 식별자를 통해서 위치를 파악함
- 근데 메모리가 옴청 커지면 비트만으로 위치파악하는거 어려움 -> 그래서 나온거 바이트(Byte)

#### 바이트(Byte)

- 8개의 비트로 구성, 1 바이트당 2의 8승(256)개 표현 가능
- C,C++,JAVA는 메모리의 낭비를 줄일라고 타입별로 메모리 영역 나눔
- 근데 JS는 상대적으로 최근에 만들어져서 메모리 관리에 대한 압박이 덜함
- 그래서 숫자의 경우에는 구분 안하고 64비트(8바이트)내에서 거의 다 표현함(물론 그것보다 큰 수 나오면 BigInt이런거 쓰는것 같음,, 추측)
  ~~이 부분은 개인적으로 개이득이라고 생각함.. 숫자는 숫자지,, 이걸 다 일일이 계산하려면 머리아플거 같음..~~

이를 통해 말하고자 하는건 `비트는 고유한 식별자 통해서 데이터 구별`, `바이트는 메모리의 주소값을 통해서 데이터를 관리`한다는 사실

#### 식별자와 변수

```
let a = 3  // 여기서 `a`는 식별자 `3`은 변수를 의미한다.

```

- 식별자
  : 데이터를 식별하는데 사용하는 이름
- 변수
  : 변할 수 있는 수, 변할 수 있는 무언가(데이터), 숫자, 문자열, 객체, 배열 등등
  : 변경가능한 데이터가 담길 수 있는 그릇, 공간

### 변수 선언과 데이터 할당

- 일단 데이터를 할당할 때, 크게 **변수영역**과 **데이터 영역**으로 나뉜다.
- 어떤 변수에 값을 저장한다고 했을 때 변수영역에 바로 값을 저장하지 않는다.
- 변수영역은 해당 변수와 거기에 들어가야 하는 값들이 있는 주소값을 적어준다.
- 그럼 실제 데이터는? 데이터영역 안에 저장이 되어있다.
- 왜 이렇게 나눈걸까? 데이터 변환을 자유롭게 하고 메모리를 효율적으로 관리하기 위해서
  ex) 변수 a,b,c,d,e,f ...많은 변수들이 있다고 하고 얘네 모두 5라는 값을 가진다고 했을때, 만약 변수와 값을 한쌍에서 같이 저장을 한다면 변수에 해당하는 모든 값들의 메모리까지 다 저장해야한다. 하지만 데이터 영역에 5를 넣고 모든 변수들이 값은 주소값을 가리키게 한다면 와우,, 메모리를 효율적으로 관리할 수 있겠지
- 여기서 핵심은 **기존 문자열에 어떤 변환을 가하든 무조건 새로 값을 만들어 별도의 공간에 저장!**
  - 즉, 내가 abc를 abcd로 고치고 싶다고 할 때 abc+d 가 되는게 아니라 abcd를 위한 공간을 따로 만들어 저장한다는것 즉 abc, abcd 모두 존재(이래서 기본형 데이터들은 **불변성**을 띠게됨)

### 기본형 데이터와 참조형 데이터

#### 그럼 불변값과 상수는 같은건가??

일단 No 이걸 알아보기 전에 변수와 상수의 차이 부터 알아보자

```
					변수 | 상수
```

변수: 바꿀 수 있는 수
상수: 바꿀 수 없는 수

변경가능성의 기준: 변수영역의 메모리(별표)
(한번 데이터 할당이 이루어진 변수 공간에 다른 데이터를 재할당 가능한지)

```
					불변값 !== 상수

```

불변값의 기준: 데이터 영역의 메모리
불변값: 한번 만들어진 값은 가비지 컬렉팅 당하지 않는 한 영원히 변하지 않음

=> 정리하면 상수와 불변값은 개념자체가 다름. 변수와 상수는 변수 영역의 메모리의 주소값을 바꿀 수 있는지 없는지에 따른거고 불변값은 변수영역의 주소값과는 관계없이 데이터가 변형되지 않고 계속 그대로 남아있는걸 의미하는 듯

#### 가변값

- 보통 참조형 데이터는 가변값이지만 설정에 따라서 변경할 수 없도록 불변값으로 만들 수 있음
- 여기서 참조형 데이터는 데이터 영역은 그대로 불변으로 둔 채 변수에 다른 값을 얼마든지 대입할 수 있기 때문에 불변하지 않다고 하는 것임
- 객체의 변수 영역이 별도로 존재한다는 참조형의 특징임

#### 중첩객체

- 참조형 데이터 프로퍼티에 다시 참조형 데이터를 할당하는 경우

#### 참조카운트

- 어떤 데이터에 대해 자신의 주소를 참조하는 변수의 개수
  -> 참조 카운트가 0인 메모리의 주소는 가비지 컬렉터의 수거 대상이 된다.
  -> 가비지 컬렉터는 런타임 환경에 따라 특정 시점, 메모리가 포화될 때 자동으로 수거 대상들을 수거한다.

#### 변수의 복사, 비교

- 변수를 복사하는 과정은 기본형, 참조형 모두 같은 주소를 바라보게 된다는 점에서는 동일하다.
- 하지만, 할당에서 차이가 있음!!
  **변수의 복사 이후 값을 변경했을 때**
  - 기본형: 변수영역의 데이터 주소값이 달라짐
  - 참조형: 변수영역의 데이터 주소값이 달라지지 않음
    => 기본형 변수 a,b는 복사 이후 값이 변경될 때 서로 다른 주소를 바라보나, 참조형 변수 obj, obj2는 여전히 같은 주소를 바라보는 같은 객체라고 판단함

_**! 우리는 보통 JS의 기본형은 값을 복사하고 참조형은 주소값을 복사한다고 알고있지만 사실 어떤 데이터 타입이든 주소값은 복제한다. 다만 기본형은 주소값을 복사하는 과정이 한번, 참조형은 한번 더 과정을 거치게 된다는 사실이다. **_

_**중요! 여기서 우리가 바꾼건 객체 자체가 아니라 객체 안의 property 값이라는 사실. 따라서 만약 새로운 객체가 할당 되면 참조형도 값이 달라짐! 여기서 알 수 있는건 참조형 데이터가 가변값이라는 사실은 그 내부의 프로퍼티를 변경할 때만 성립한다는 사실! 데이터 자체의 변경은 더이상 가변값이 아님! **_

### 불변 객체

- 앞서 언급되었듯 참조형에서 가변이 성립하는건 내부의 프로퍼티를 바꿀 때만임
- 데이터 자체를 변경하게 되면 기존 데이터는 변하지 않음(불변성을 띰)
- 우리는 이를 통해 불변객체를 만들 수 있다.

**잠깐..! 그럼 왜 불변객체가 필요하나**

- 앞의 정보와 비교하여 정보가 바뀐 시점의 알림을 보내는 경우
- 바뀌기 전 정보와 바뀐 후의 정보를 가시적으로 보여줘야 할 때 예제에서 처럼 프로퍼티들을 그대로 다 옮기기에는 바뀌지 않는 부분들을 하드코딩해야하는 굉장히 비효율적인 상황 발생
- so what we need is 프로퍼티의 개수에 상관없이 복사하는 방법 필요

#### for..in을 활용한 복사

- 내부 프로퍼티들을 반복문을 통해 돌며 새로운 변수에 할당하여 값을 복사할 수 있다.
- 하지만 문제는 바로 아래 단계의 얕은 복사만 가능하다는 사실이다. 따라서 중첩되어 있는 객체의 경우 복사가 어렵다.

#### 얕은 복사와 깊은 복사

- 얕은 복사: 바로 아래 단계의 값만 복사, 중첩 객체 시 안에있는 객체는 복사하지 않는다. 따라서 사본과 원본이 서로 영향을 미친다.
- 깊은 복사: 내부의 값들을 찾아서 하나하나 전부 복사하는 방법
- 객체의 프로퍼티 중 그 값이 기본형인 경우 그대로 복사되지만, 참조형 데이터들은 내부의 프로퍼티들도 복사해주어야 한다.

#### 깊은 복사 방법

1. 재귀적으로 수행 시 깊은 복사 가능

```
for(let prop in target){
result[prop] = copyObjectDeep(target[prop])
}
```

2. ES6의 hasOwnProperty 메서드를 활용하여 프로토타입 체이닝을 통해 사용가능(근데 별로 많이 쓰이지는 않는듯하다..)

3. JSON 문자열로 전환하여 복사하기

- 가장 깔끔한 방법으로 복사를 할 수 있다고 하지만 method, proto, getter, setter같은 애들은 무시되기 때문에 httpRequest와 같은 순수정보에 주로 이용된다.

### undefined 와null

- undefined
  : 사용자가 명시 가능
  : 자바스크립트에서 자동 부여 (값을 대입하지 않은 변수, 객체 내부에 존재하지 않는 프로퍼티 접근, return문이 없을 때)

- undefined를 직접 명시할 때 문제점은 만약 배열에서 undefined를 배열에서 할당하면 배열 메소드릐 순회 대상에서 제외된다 따라서 undefined 대신 null을 이용하기!
